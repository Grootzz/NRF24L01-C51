C51 COMPILER V9.00   MAIN                                                                  07/03/2016 09:26:35 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: D:\Keil\C51\BIN\C51.EXE main.C BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /**************************************************
   2          À´Ô´£ºÍøÉÏ
   3          ¸ÄÐ´£ºbluefeel
   4          Ê±¼ä£º10-03-13
   5          µ¥Î»£º¹ðÁÖÀí¹¤´óÑ§
   6          /**************************************************/
   7          
   8          #include <reg51.h>
   9          #include <api.h>
  10          
  11          #define uchar unsigned char
  12          
  13          /***************************************************/
  14          #define TX_ADR_WIDTH   5  // 5×Ö½Ú¿í¶ÈµÄ·¢ËÍ/½ÓÊÕµØÖ·
  15          #define TX_PLOAD_WIDTH 4  // Êý¾ÝÍ¨µÀÓÐÐ§Êý¾Ý¿í¶È
  16          #define LED P0
  17          
  18          uchar code TX_ADDRESS[TX_ADR_WIDTH] = {0x34,0x43,0x10,0x10,0x01};  // ¶¨ÒåÒ»¸ö¾²Ì¬·¢ËÍµØÖ·
  19          uchar RX_BUF[TX_PLOAD_WIDTH];
  20          uchar TX_BUF[TX_PLOAD_WIDTH];
  21          uchar flag;
  22          uchar DATA = 0x01;
  23          uchar bdata sta;
  24          sbit  RX_DR      = sta^6;
  25          sbit  TX_DS      = sta^5;
  26          sbit  MAX_RT = sta^4;
  27          /**************************************************/
  28          
  29          /**************************************************
  30          º¯Êý: init_io()
  31          
  32          ÃèÊö:
  33              ³õÊ¼»¯IO
  34          /**************************************************/
  35          void init_io(void)
  36          {
  37   1              CE  = 0;        // ´ý»ú
  38   1              CSN = 1;        // SPI½ûÖ¹
  39   1              SCK = 0;        // SPIÊ±ÖÓÖÃµÍ
  40   1              IRQ = 1;        // ÖÐ¶Ï¸´Î»
  41   1              LED = 0xff;             // ¹Ø±ÕÖ¸Ê¾µÆ
  42   1      }
  43          /**************************************************/
  44          
  45          /**************************************************
  46          º¯Êý£ºdelay_ms()
  47          
  48          ÃèÊö£º
  49              ÑÓ³ÙxºÁÃë
  50          /**************************************************/
  51          void delay_ms(uchar x)
  52          {
  53   1          uchar i, j;
  54   1          i = 0;
  55   1          for(i=0; i<x; i++)
C51 COMPILER V9.00   MAIN                                                                  07/03/2016 09:26:35 PAGE 2   

  56   1          {
  57   2             j = 250;
  58   2             while(--j);
  59   2                 j = 250;
  60   2             while(--j);
  61   2          }
  62   1      }
  63          /**************************************************/
  64          
  65          /**************************************************
  66          º¯Êý£ºSPI_RW()
  67          
  68          ÃèÊö£º
  69              ¸ù¾ÝSPIÐ­Òé£¬Ð´Ò»×Ö½ÚÊý¾Ýµ½nRF24L01£¬Í¬Ê±´ÓnRF24L01
  70                  ¶Á³öÒ»×Ö½Ú
  71          /**************************************************/
  72          uchar SPI_RW(uchar byte)
  73          {
  74   1              uchar i;
  75   1              for(i=0; i<8; i++)          // Ñ­»·8´Î
  76   1              {
  77   2                      MOSI = (byte & 0x80);   // byte×î¸ßÎ»Êä³öµ½MOSI
  78   2                      byte <<= 1;             // µÍÒ»Î»ÒÆÎ»µ½×î¸ßÎ»
  79   2                      SCK = 1;                // À­¸ßSCK£¬nRF24L01´ÓMOSI¶ÁÈë1Î»Êý¾Ý£¬Í¬Ê±´ÓMISOÊä³ö1Î»Êý¾Ý
  80   2                      byte |= MISO;           // ¶ÁMISOµ½byte×îµÍÎ»
  81   2                      SCK = 0;                // SCKÖÃµÍ
  82   2              }
  83   1          return(byte);               // ·µ»Ø¶Á³öµÄÒ»×Ö½Ú
  84   1      }
  85          /**************************************************/
  86          
  87          /**************************************************
  88          º¯Êý£ºSPI_RW_Reg()
  89          
  90          ÃèÊö£º
  91              Ð´Êý¾Ývalueµ½reg¼Ä´æÆ÷
  92          /**************************************************/
  93          uchar SPI_RW_Reg(uchar reg, uchar value)
  94          {
  95   1              uchar status;
  96   1              CSN = 0;                   // CSNÖÃµÍ£¬¿ªÊ¼´«ÊäÊý¾Ý
  97   1              status = SPI_RW(reg);      // Ñ¡Ôñ¼Ä´æÆ÷£¬Í¬Ê±·µ»Ø×´Ì¬×Ö
  98   1              SPI_RW(value);             // È»ºóÐ´Êý¾Ýµ½¸Ã¼Ä´æÆ÷
  99   1              CSN = 1;                   // CSNÀ­¸ß£¬½áÊøÊý¾Ý´«Êä
 100   1              return(status);            // ·µ»Ø×´Ì¬¼Ä´æÆ÷
 101   1      }
 102          /**************************************************/
 103          
 104          /**************************************************
 105          º¯Êý£ºSPI_Read()
 106          
 107          ÃèÊö£º
 108              ´Óreg¼Ä´æÆ÷¶ÁÒ»×Ö½Ú
 109          /**************************************************/
 110          uchar SPI_Read(uchar reg)
 111          {
 112   1              uchar reg_val;
 113   1              CSN = 0;                    // CSNÖÃµÍ£¬¿ªÊ¼´«ÊäÊý¾Ý
 114   1              SPI_RW(reg);                // Ñ¡Ôñ¼Ä´æÆ÷
 115   1              reg_val = SPI_RW(0);        // È»ºó´Ó¸Ã¼Ä´æÆ÷¶ÁÊý¾Ý
 116   1              CSN = 1;                    // CSNÀ­¸ß£¬½áÊøÊý¾Ý´«Êä
 117   1              return(reg_val);            // ·µ»Ø¼Ä´æÆ÷Êý¾Ý
C51 COMPILER V9.00   MAIN                                                                  07/03/2016 09:26:35 PAGE 3   

 118   1      }
 119          /**************************************************/
 120          
 121          /**************************************************
 122          º¯Êý£ºSPI_Read_Buf()
 123          
 124          ÃèÊö£º
 125              ´Óreg¼Ä´æÆ÷¶Á³öbytes¸ö×Ö½Ú£¬Í¨³£ÓÃÀ´¶ÁÈ¡½ÓÊÕÍ¨µÀ
 126                  Êý¾Ý»ò½ÓÊÕ/·¢ËÍµØÖ·
 127          /**************************************************/
 128          uchar SPI_Read_Buf(uchar reg, uchar * pBuf, uchar bytes)
 129          {
 130   1              uchar status, i;
 131   1              CSN = 0;                    // CSNÖÃµÍ£¬¿ªÊ¼´«ÊäÊý¾Ý
 132   1              status = SPI_RW(reg);       // Ñ¡Ôñ¼Ä´æÆ÷£¬Í¬Ê±·µ»Ø×´Ì¬×Ö
 133   1              for(i=0; i<bytes; i++)
 134   1              pBuf[i] = SPI_RW(0);    // Öð¸ö×Ö½Ú´ÓnRF24L01¶Á³ö
 135   1              CSN = 1;                    // CSNÀ­¸ß£¬½áÊøÊý¾Ý´«Êä
 136   1              return(status);             // ·µ»Ø×´Ì¬¼Ä´æÆ÷
 137   1      }
 138          /**************************************************/
 139          
 140          /**************************************************
 141          º¯Êý£ºSPI_Write_Buf()
 142          
 143          ÃèÊö£º
 144              °ÑpBuf»º´æÖÐµÄÊý¾ÝÐ´Èëµ½nRF24L01£¬Í¨³£ÓÃÀ´Ð´Èë·¢
 145                  ÉäÍ¨µÀÊý¾Ý»ò½ÓÊÕ/·¢ËÍµØÖ·
 146          /**************************************************/
 147          uchar SPI_Write_Buf(uchar reg, uchar * pBuf, uchar bytes)
 148          {
 149   1              uchar status, i;
 150   1              CSN = 0;                    // CSNÖÃµÍ£¬¿ªÊ¼´«ÊäÊý¾Ý
 151   1              status = SPI_RW(reg);       // Ñ¡Ôñ¼Ä´æÆ÷£¬Í¬Ê±·µ»Ø×´Ì¬×Ö
 152   1              for(i=0; i<bytes; i++)
 153   1              SPI_RW(pBuf[i]);        // Öð¸ö×Ö½ÚÐ´ÈënRF24L01
 154   1              CSN = 1;                    // CSNÀ­¸ß£¬½áÊøÊý¾Ý´«Êä
 155   1              return(status);             // ·µ»Ø×´Ì¬¼Ä´æÆ÷
 156   1      }
 157          /**************************************************/
 158          
 159          /**************************************************
 160          º¯Êý£ºRX_Mode()
 161          
 162          ÃèÊö£º
 163              Õâ¸öº¯ÊýÉèÖÃnRF24L01Îª½ÓÊÕÄ£Ê½£¬µÈ´ý½ÓÊÕ·¢ËÍÉè±¸µÄÊý¾Ý°ü
 164          /**************************************************/
 165          void RX_Mode(void)
 166          {
 167   1              CE = 0;
 168   1              SPI_Write_Buf(WRITE_REG + RX_ADDR_P0, TX_ADDRESS, TX_ADR_WIDTH);  // ½ÓÊÕÉè±¸½ÓÊÕÍ¨µÀ0Ê¹ÓÃºÍ·¢ËÍÉè±¸ÏàÍ
             -¬µÄ·¢ËÍµØÖ·
 169   1              SPI_RW_Reg(WRITE_REG + EN_AA, 0x01);               // Ê¹ÄÜ½ÓÊÕÍ¨µÀ0×Ô¶¯Ó¦´ð
 170   1              SPI_RW_Reg(WRITE_REG + EN_RXADDR, 0x01);           // Ê¹ÄÜ½ÓÊÕÍ¨µÀ0
 171   1              SPI_RW_Reg(WRITE_REG + RF_CH, 40);                 // Ñ¡ÔñÉäÆµÍ¨µÀ0x40
 172   1              SPI_RW_Reg(WRITE_REG + RX_PW_P0, TX_PLOAD_WIDTH);  // ½ÓÊÕÍ¨µÀ0Ñ¡ÔñºÍ·¢ËÍÍ¨µÀÏàÍ¬ÓÐÐ§Êý¾Ý¿í¶È
 173   1              SPI_RW_Reg(WRITE_REG + RF_SETUP, 0x07);            // Êý¾Ý´«ÊäÂÊ1Mbps£¬·¢Éä¹¦ÂÊ0dBm£¬µÍÔëÉù·Å´óÆ÷ÔöÒæ
 174   1              SPI_RW_Reg(WRITE_REG + CONFIG, 0x0f);              // CRCÊ¹ÄÜ£¬16Î»CRCÐ£Ñé£¬ÉÏµç£¬½ÓÊÕÄ£Ê½
 175   1              CE = 1;                                            // À­¸ßCEÆô¶¯½ÓÊÕÉè±¸
 176   1      }
 177          /**************************************************/
 178          
C51 COMPILER V9.00   MAIN                                                                  07/03/2016 09:26:35 PAGE 4   

 179          /**************************************************
 180          º¯Êý£ºTX_Mode()
 181          
 182          ÃèÊö£º
 183              Õâ¸öº¯ÊýÉèÖÃnRF24L01Îª·¢ËÍÄ£Ê½£¬£¨CE=1³ÖÐøÖÁÉÙ10us£©£¬
 184                  130usºóÆô¶¯·¢Éä£¬Êý¾Ý·¢ËÍ½áÊøºó£¬·¢ËÍÄ£¿é×Ô¶¯×ªÈë½ÓÊÕ
 185                  Ä£Ê½µÈ´ýÓ¦´ðÐÅºÅ¡£
 186          /**************************************************/
 187          void TX_Mode(uchar * BUF)
 188          {
 189   1              CE = 0;
 190   1              SPI_Write_Buf(WRITE_REG + TX_ADDR, TX_ADDRESS, TX_ADR_WIDTH);     // Ð´Èë·¢ËÍµØÖ·
 191   1              SPI_Write_Buf(WRITE_REG + RX_ADDR_P0, TX_ADDRESS, TX_ADR_WIDTH);  // ÎªÁËÓ¦´ð½ÓÊÕÉè±¸£¬½ÓÊÕÍ¨µÀ0µØÖ·ºÍ·
             -¢ËÍµØÖ·ÏàÍ¬
 192   1              SPI_Write_Buf(WR_TX_PLOAD, BUF, TX_PLOAD_WIDTH);                  // Ð´Êý¾Ý°üµ½TX FIFO
 193   1              SPI_RW_Reg(WRITE_REG + EN_AA, 0x01);       // Ê¹ÄÜ½ÓÊÕÍ¨µÀ0×Ô¶¯Ó¦´ð
 194   1              SPI_RW_Reg(WRITE_REG + EN_RXADDR, 0x01);   // Ê¹ÄÜ½ÓÊÕÍ¨µÀ0
 195   1              SPI_RW_Reg(WRITE_REG + SETUP_RETR, 0x0a);  // ×Ô¶¯ÖØ·¢ÑÓÊ±µÈ´ý250us+86us£¬×Ô¶¯ÖØ·¢10´Î
 196   1              SPI_RW_Reg(WRITE_REG + RF_CH, 40);         // Ñ¡ÔñÉäÆµÍ¨µÀ0x40
 197   1              SPI_RW_Reg(WRITE_REG + RF_SETUP, 0x07);    // Êý¾Ý´«ÊäÂÊ1Mbps£¬·¢Éä¹¦ÂÊ0dBm£¬µÍÔëÉù·Å´óÆ÷ÔöÒæ
 198   1              SPI_RW_Reg(WRITE_REG + CONFIG, 0x0e);      // CRCÊ¹ÄÜ£¬16Î»CRCÐ£Ñé£¬ÉÏµç
 199   1              CE = 1;
 200   1      }
 201          /**************************************************/
 202          
 203          /**************************************************
 204          º¯Êý£ºCheck_ACK()
 205          
 206          ÃèÊö£º
 207              ¼ì²é½ÓÊÕÉè±¸ÓÐÎÞ½ÓÊÕµ½Êý¾Ý°ü£¬Éè¶¨Ã»ÓÐÊÕµ½Ó¦´ðÐÅ
 208                  ºÅÊÇ·ñÖØ·¢
 209          /**************************************************/
 210          uchar Check_ACK(bit clear)
 211          {
 212   1              while(IRQ);
 213   1              sta = SPI_RW(NOP);                    // ·µ»Ø×´Ì¬¼Ä´æÆ÷
 214   1              if(MAX_RT)
 215   1                      if(clear)                         // ÊÇ·ñÇå³ýTX FIFO£¬Ã»ÓÐÇå³ýÔÚ¸´Î»MAX_RTÖÐ¶Ï±êÖ¾ºóÖØ·¢
 216   1                              SPI_RW(FLUSH_TX);
 217   1              SPI_RW_Reg(WRITE_REG + STATUS, sta);  // Çå³ýTX_DS»òMAX_RTÖÐ¶Ï±êÖ¾
 218   1              IRQ = 1;
 219   1              if(TX_DS)
 220   1                      return(0x00);
 221   1              else
 222   1                      return(0xff);
 223   1      }
 224          /**************************************************/
 225          
 226          /**************************************************
 227          º¯Êý£ºCheckButtons()
 228          
 229          ÃèÊö£º
 230              ¼ì²é°´¼üÊÇ·ñ°´ÏÂ£¬°´ÏÂÔò·¢ËÍÒ»×Ö½ÚÊý¾Ý
 231          /**************************************************/
 232          void CheckButtons()
 233          {
 234   1              P1 |= 0x00;
 235   1              if(!(P1 & 0x01))                            // ¶ÁÈ¡P3^0×´Ì¬
 236   1              {
 237   2                      delay_ms(20);
 238   2                      if(!(P1 & 0x01))                            // ¶ÁÈ¡P3^0×´Ì¬
 239   2                      {
C51 COMPILER V9.00   MAIN                                                                  07/03/2016 09:26:35 PAGE 5   

 240   3                              TX_BUF[0] = ~DATA;          // Êý¾ÝËÍµ½»º´æ
 241   3                              TX_Mode(TX_BUF);                        // °ÑnRF24L01ÉèÖÃÎª·¢ËÍÄ£Ê½²¢·¢ËÍÊý¾Ý
 242   3                              LED = ~DATA;                    // Êý¾ÝËÍµ½LEDÏÔÊ¾
 243   3                              Check_ACK(1);               // µÈ´ý·¢ËÍÍê±Ï£¬Çå³ýTX FIFO
 244   3                              delay_ms(250);
 245   3                              delay_ms(250);
 246   3                              LED = 0xff;                             // ¹Ø±ÕLED
 247   3                              RX_Mode();                              // ÉèÖÃÎª½ÓÊÕÄ£Ê½
 248   3                              while(!(P1 & 0x01));
 249   3                              DATA <<= 1;
 250   3                              if(!DATA)
 251   3                                      DATA = 0x01;
 252   3                      }
 253   2              }
 254   1      }
 255          /**************************************************/
 256          
 257          /**************************************************
 258          º¯Êý£ºmain()
 259          
 260          ÃèÊö£º
 261              Ö÷º¯Êý
 262          /**************************************************/
 263          void main(void)
 264          {
 265   1              init_io();                            // ³õÊ¼»¯IO
 266   1              RX_Mode();                            // ÉèÖÃÎª½ÓÊÕÄ£Ê½
 267   1              while(1)
 268   1              {
 269   2                      CheckButtons();           // °´¼üÉ¨Ãè
 270   2                      sta = SPI_Read(STATUS);   // ¶Á×´Ì¬¼Ä´æÆ÷
 271   2                  if(RX_DR)                             // ÅÐ¶ÏÊÇ·ñ½ÓÊÜµ½Êý¾Ý
 272   2                      {
 273   3                              SPI_Read_Buf(RD_RX_PLOAD, RX_BUF, TX_PLOAD_WIDTH);  // ´ÓRX FIFO¶Á³öÊý¾Ý
 274   3                              flag = 1;
 275   3                      }
 276   2                      SPI_RW_Reg(WRITE_REG + STATUS, sta);  // Çå³ýRX_DSÖÐ¶Ï±êÖ¾
 277   2                      if(flag)                           // ½ÓÊÜÍê³É
 278   2                      {
 279   3                              flag = 0;                      // Çå±êÖ¾
 280   3                              LED = RX_BUF[0];           // Êý¾ÝËÍµ½LEDÏÔÊ¾
 281   3                              delay_ms(250);
 282   3                              delay_ms(250);
 283   3                              LED = 0xff;                    // ¹Ø±ÕLED
 284   3                      }
 285   2              }
 286   1      }
 287          /**************************************************/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    489    ----
   CONSTANT SIZE    =      5    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     11      13
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
